<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>F*.js IDE demo</title>
    <link rel="stylesheet" href="./fstar.js/fstar.ide.css">
    <link rel="stylesheet" href="./fstar.js/cm.tango.css">
    <link rel="stylesheet" href="./fira-code.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/codemirror.min.css" integrity="sha256-I8NyGs4wjbMuBSUE40o55W6k6P7tu/7G28/JGUUYCIs=" crossorigin="anonymous" />
  </head>
  <body>
    <div id="main">
      <h1>F*.js</h1>

<h1>Case study: simply-typed lambda-calculus<a class="headerlink" href="#case-study-simply-typed-lambda-calculus" title="Permalink to this headline">¶</a></h1>
<!--
<div class="code fstar literal-block">
module STLC

open FStar.Tactics
open FStar.Mul

assume val p : Type0
assume val q : Type0
assume val r : Type0

assume val f : unit -&gt; Lemma (p ==&gt; r)
assume val g : unit -&gt; Lemma (q ==&gt; r)
</div>

<div class="code fstar literal-block">
let test_cases (h : (p \/ q)) : Lemma r =
    assert_by_tactic r
        (fun () -&gt;
            let t = quote h in
            cases_or t;
            dump &quot;A&quot;;
            apply_lemma (quote f);
            apply_lemma (quote g);
            qed ())
</div>
-->

<div class="code fstar literal-block">
module STLC
</div>

open FStar.Tactics
open FStar.Mul

<div class="admonition-fixme admonition">
<p class="first admonition-title">FIXME (Cătălin)</p>
<p class="last">Any way I could have imported the existing code here without duplicating
it? Without a way to do this maintaining this document and keeping it
consistent will be a nightmare.</p>
</div>
<p>We now look at a larger case study: proving the soundness of a
type-checker for the simply-typed <span class="math">\(\lambda\)</span>-calculus (STLC). If
you&#8217;re not familiar with STLC, you can have a look at the <a class="reference external" href="http://www.cis.upenn.edu/~bcpierce/sf/current/Stlc.html">Software
Foundations book</a> for a gentle introduction given by the textual
explanations (you can ignore the Coq parts there). The formalization and
proof here closely follows the one in <a class="reference external" href="http://www.cis.upenn.edu/~bcpierce/sf/current/StlcProp.html">Software Foundations</a>. Our
proofs are, however, shorter and much more readable than Coq proofs.</p>
<div class="section" id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>We represent STLC types by the <a href="#id1"><span class="problematic" id="id2">|fstar|</span></a> inductive datatype <code class="docutils literal"><span class="pre">ty</span></code>.</p>
<div class="code fstar literal-block">
type ty =
  | TBool  : ty
  | TArrow : tin:ty -&gt; tout:ty -&gt; ty

type var = int
</div>
<p>We consider Booleans as the only base type (<code class="docutils literal"><span class="pre">TBool</span></code>). Function types
are represented by the <code class="docutils literal"><span class="pre">TArrow</span></code> constructor taking two type arguments.
For instance we write <code class="docutils literal"><span class="pre">TArrow</span> <span class="pre">TBool</span> <span class="pre">TBool</span></code> for the type of functions
taking a Boolean argument and returning a Boolean result. This would be
written as <code class="docutils literal"><span class="pre">bool</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code> in <a href="#id3"><span class="problematic" id="id4">|fstar|</span></a> syntax, and
<span class="math">\(\mathsf{bool} \to \mathsf{bool}\)</span> in paper notation.</p>
<p>We represent the expressions of STLC by the datatype <code class="docutils literal"><span class="pre">exp</span></code>.</p>
<div class="code fstar literal-block">
type exp =
  | EVar   : v:var -&gt; exp
  | EApp   : fn:exp -&gt; arg:exp -&gt; exp
  | EAbs   : v:var -&gt; vty:ty -&gt; body:exp -&gt; exp
  | ETrue  : exp
  | EFalse : exp
  | EIf    : test:exp -&gt; btrue:exp -&gt; bfalse:exp -&gt; exp
</div>
<p>Variables are represented as integer &#8220;names&#8221; decorated by the
constructor <code class="docutils literal"><span class="pre">EVar</span></code>. Variables are &#8220;bound&#8221; by lambda abstractions
(<code class="docutils literal"><span class="pre">EAbs</span></code>). For instance the identity function on Booleans is written
<code class="docutils literal"><span class="pre">EAbs</span> <span class="pre">0</span> <span class="pre">TBool</span> <span class="pre">(EVar</span> <span class="pre">0)</span></code>. In paper notation one would write this
function as <span class="math">\((\lambda x:\mathsf{bool}.~x)\)</span>. The type annotation on
the argument (<code class="docutils literal"><span class="pre">TBool</span></code>) allows for very simple type-checking. We are
not considering type inference here, to keep things simple. The
expression that applies the identity function to the <code class="docutils literal"><span class="pre">ETrue</span></code> constant
is written</p>
<div class="code fstar literal-block">
let stlc_app_id_to_true = EApp (EAbs 0 TBool (EVar 0)) ETrue
</div>
<p>(in paper notation <span class="math">\((\lambda x:\mathsf{bool}.~x)~\mathsf{true}\)</span>).</p>
<p>The language also has a conditional construct (if-then-else). For
instance, the Boolean &#8220;not&#8221; function can be written as</p>
<div class="code fstar literal-block">
let stlc_not = EAbs 0 TBool (EIf (EVar 0) EFalse ETrue)
</div>
<p>(in paper notation
<span class="math">\(\lambda x:\mathsf{bool}.~\mathsf{if }~x~\mathsf{ then~false~else~true}\)</span>).</p>
</div>
<div class="section" id="operational-semantics">
<h2>Operational semantics<a class="headerlink" href="#operational-semantics" title="Permalink to this headline">¶</a></h2>
<p>We define a standard small-step call-by-value interpreter for STLC. The
final result of successfully evaluating an expression is called a
<em>value</em>. We postulate that functions and the Boolean constants are
values by defining <code class="docutils literal"><span class="pre">is_value</span></code>, a boolean predicate on expressions (a
total function):</p>
<div class="code fstar literal-block">
val is_value : exp -&gt; Tot bool
let is_value e =
  match e with
  | EAbs _ _ _
  | ETrue
  | EFalse     -&gt; true
  | _          -&gt; false
</div>
<p>The <code class="docutils literal"><span class="pre">EAbs</span></code>, <code class="docutils literal"><span class="pre">ETrue</span></code>, and <code class="docutils literal"><span class="pre">EFalse</span></code> cases share the same
right-hand-side (<code class="docutils literal"><span class="pre">true</span></code>), which is a way to prevent duplication in
definitions.</p>
<p>In order to give a semantics to function applications we define a
function <code class="docutils literal"><span class="pre">subst</span> <span class="pre">x</span> <span class="pre">e</span> <span class="pre">e'</span></code> that substitutes <code class="docutils literal"><span class="pre">x</span></code> with <code class="docutils literal"><span class="pre">e</span></code> in <code class="docutils literal"><span class="pre">e'</span></code>:</p>
<div class="code fstar literal-block">
val subst : int -&gt; exp -&gt; exp -&gt; Tot exp
let rec subst x e e' =
  match e' with
  | EVar x' -&gt; if x = x' then e else e'
  | EAbs x' t e1 -&gt;
      EAbs x' t (if x = x' then e1 else (subst x e e1))
  | EApp e1 e2 -&gt; EApp (subst x e e1) (subst x e e2)
  | ETrue -&gt; ETrue
  | EFalse -&gt; EFalse
  | EIf e1 e2 e3 -&gt; EIf (subst x e e1) (subst x e e2) (subst x e e3)
</div>
<p>We traverse the expression and when we reach a variable <code class="docutils literal"><span class="pre">(EVar</span> <span class="pre">x')</span></code> we
check whether this is the variable <code class="docutils literal"><span class="pre">x</span></code> we want to substitute, and if
it is we replace it by <code class="docutils literal"><span class="pre">e</span></code>. For lambda abstractions <code class="docutils literal"><span class="pre">(EAbs</span> <span class="pre">x'</span> <span class="pre">t</span> <span class="pre">e1)</span></code>
we only substitute inside the body <code class="docutils literal"><span class="pre">e1</span></code> if <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">x'</span></code> are
different; if they are the same we leave the body unchanged. The reason
for this is that the <code class="docutils literal"><span class="pre">x</span></code> in <code class="docutils literal"><span class="pre">e1</span></code> is bound by the abstraction: it is
a new, local name that just happens to be spelled the same as some
global name <code class="docutils literal"><span class="pre">x</span></code>. The global <code class="docutils literal"><span class="pre">x</span></code> is no longer accessible in this
scope, since it is shadowed by the local <code class="docutils literal"><span class="pre">x</span></code>. The other cases are
straightforward.</p>
<blockquote>
<div><strong>Note for experts</strong>: Because we will only reduce closed
expressions, where all variables are bound by previous lambdas, we
will only ever substitute closed expressions <code class="docutils literal"><span class="pre">e</span></code>, and this naive
definition of substitution is good enough. Substitution would become
trickier to define or the representation of variables would have to
change if we were considering the case where <code class="docutils literal"><span class="pre">e</span></code>, the expression
replacing a variable in some other expression, may itself contain
free variables.</div></blockquote>
<p>Given the definition of values and of substitution we can now define a
small-step interpreter, as a function <code class="docutils literal"><span class="pre">step</span></code> that takes an expression
<code class="docutils literal"><span class="pre">e</span></code> and it either returns the expression to which <code class="docutils literal"><span class="pre">e</span></code> reduces in a
single step, or it returns <code class="docutils literal"><span class="pre">None</span></code> in case of an error (all errors in
this language are typing errors, and will be prevented statically by the
type system).</p>
<pre class="code fstar literal-block">
val step : exp -&gt; Tot (option exp)
  let rec step e =
  match e with
  | EApp e1 e2 -&gt;
      if is_value e1 then
        if is_value e2 then
          match e1 with
          | EAbs x t e' -&gt; Some (subst x e2 e')
          | _           -&gt; None
        else
          match (step e2) with
          | Some e2' -&gt; Some (EApp e1 e2')
          | None     -&gt; None
      else
        (match (step e1) with
        | Some e1' -&gt; Some (EApp e1' e2)
        | None     -&gt; None)
  | EIf e1 e2 e3 -&gt;
      if is_value e1 then
        match e1 with
        | ETrue   -&gt; Some e2
        | EFalse  -&gt; Some e3
        | _       -&gt; None
      else
        (match (step e1) with
        | Some e1' -&gt; Some (EIf e1' e2 e3)
        | None     -&gt; None)
  | _ -&gt; None
</pre>
<p>We execute an application expression <code class="docutils literal"><span class="pre">EApp</span> <span class="pre">e1</span> <span class="pre">e2</span></code> in multiple steps by
first reducing <code class="docutils literal"><span class="pre">e1</span></code> to a value, then reducing <code class="docutils literal"><span class="pre">e2</span></code> to a value
(following a <em>call-by-value</em> evaluation order), and if additionally
<code class="docutils literal"><span class="pre">e1</span></code> is an abstraction <code class="docutils literal"><span class="pre">EAbs</span> <span class="pre">x</span> <span class="pre">t</span> <span class="pre">e'</span></code>we continue by substituting
the formal argument <code class="docutils literal"><span class="pre">x</span></code> by the actual argument <code class="docutils literal"><span class="pre">e2</span></code>. If not we
signal a dynamic typing error (a non-functional value is applied to
arguments) by returning <code class="docutils literal"><span class="pre">None</span></code>. For <code class="docutils literal"><span class="pre">EIf</span> <span class="pre">e1</span> <span class="pre">e2</span> <span class="pre">e3</span></code> we first reduce
the guard <code class="docutils literal"><span class="pre">e1</span></code>: if the guard reduces to <code class="docutils literal"><span class="pre">true</span></code> then we continue with
<code class="docutils literal"><span class="pre">e2</span></code>, if the guard reduces to <code class="docutils literal"><span class="pre">false</span></code> we continue with <code class="docutils literal"><span class="pre">e3</span></code>, and
if the guard reduces to something else (e.g. a function) we report a
dynamic typing error. The <code class="docutils literal"><span class="pre">None</span> <span class="pre">-&gt;</span> <span class="pre">None</span></code> cases simply propagate errors
to the top level.</p>
<pre class="code fstar literal-block">
let _ = assert (step (EApp (EAbs 0 TBool (EVar 0)) ETrue) = Some ETrue)
let _ = assert (step (EApp ETrue ETrue) = None)
</pre>
</div>
<div class="section" id="type-checker">
<h2>Type-checker<a class="headerlink" href="#type-checker" title="Permalink to this headline">¶</a></h2>
<p>In order to assign a type to a term, we need to know what assumptions we
should make about the types of its free variables. So typing happens
with respect to a typing environment—a mapping from the variables in
scope to their types. We represent such partial maps as functions taking
an integer variable name and returning an optional type:</p>
<pre class="code fstar literal-block">
type env = int -&gt; Tot (option ty)
</pre>
<p>We start type-checking closed terms in the empty environment, i.e.
initially no variables are in scope.</p>
<pre class="code fstar literal-block">
val empty : env
let empty = fun _ -&gt; None
</pre>
<p>When we move under a binder we extend the typing environment.</p>
<pre class="code fstar literal-block">
val extend : env -&gt; int -&gt; ty -&gt; Tot env
let extend g x t = fun x' -&gt; if x = x' then Some t else g x'
</pre>
<p>For instance we type-check <code class="docutils literal"><span class="pre">EAbs</span> <span class="pre">x</span> <span class="pre">t</span> <span class="pre">e</span></code> in typing environment <code class="docutils literal"><span class="pre">g</span></code> by
first type-checking the body <code class="docutils literal"><span class="pre">e</span></code> in the environment <code class="docutils literal"><span class="pre">extend</span> <span class="pre">g</span> <span class="pre">x</span> <span class="pre">t</span></code>.</p>
<p>The type-checker is a total function taking an environment <code class="docutils literal"><span class="pre">g</span></code> and an
expression <code class="docutils literal"><span class="pre">e</span></code> and producing either the type of <code class="docutils literal"><span class="pre">e</span></code> or <code class="docutils literal"><span class="pre">None</span></code> if
<code class="docutils literal"><span class="pre">e</span></code> is not well-typed.</p>
<pre class="code fstar literal-block">
val typing : env -&gt; exp -&gt; Tot (option ty)
let rec typing g e =
  match e with
  | EVar x -&gt; g x
  | EAbs x t e1 -&gt;
      (match typing (extend g x t) e1 with
      | Some t' -&gt; Some (TArrow t t')
      | None    -&gt; None)
  | EApp e1 e2 -&gt;
      (match typing g e1, typing g e2 with
      | Some (TArrow t11 t12), Some t2 -&gt; if t11 = t2 then Some t12 else None
      | _                    , _       -&gt; None)
  | ETrue  -&gt; Some TBool
  | EFalse -&gt; Some TBool
  | EIf e1 e2 e3 -&gt;
      (match typing g e1, typing g e2, typing g e3 with
      | Some TBool, Some t2, Some t3 -&gt; if t2 = t3 then Some t2 else None
      | _         , _      , _       -&gt; None)
</pre>
<p>Variables are simply looked up in the environment. For abstractions
<code class="docutils literal"><span class="pre">EAbs</span> <span class="pre">x</span> <span class="pre">t</span> <span class="pre">e1</span></code> we type-check the body <code class="docutils literal"><span class="pre">e1</span></code> under the environment
<code class="docutils literal"><span class="pre">extend</span> <span class="pre">g</span> <span class="pre">x</span> <span class="pre">t</span></code>, as explained above. If that succeeds and produces a
type <code class="docutils literal"><span class="pre">t'</span></code>, then the whole abstraction is given type <code class="docutils literal"><span class="pre">TArrow</span> <span class="pre">t</span> <span class="pre">t'</span></code>.
For applications <code class="docutils literal"><span class="pre">EApp</span> <span class="pre">e1</span> <span class="pre">e2</span></code> we type-check <code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e2</span></code>
separately, and if <code class="docutils literal"><span class="pre">e1</span></code> has a function type <code class="docutils literal"><span class="pre">TArrow</span> <span class="pre">t11</span> <span class="pre">t12</span></code> and
<code class="docutils literal"><span class="pre">e2</span></code> has type <code class="docutils literal"><span class="pre">t11</span></code>, then the whole application has type <code class="docutils literal"><span class="pre">t12</span></code>.
<code class="docutils literal"><span class="pre">ETrue</span></code> and <code class="docutils literal"><span class="pre">EFalse</span></code> have type <code class="docutils literal"><span class="pre">TBool</span></code>. For conditionals, we
require that the guard has type <code class="docutils literal"><span class="pre">TBool</span></code> and the two branches have the
same type, which is also the type of the conditional.</p>
</div>
<div class="section" id="soundness-proof">
<h2>Soundness proof<a class="headerlink" href="#soundness-proof" title="Permalink to this headline">¶</a></h2>
<div class="admonition-fixme admonition">
<p class="first admonition-title">FIXME (Cătălin)</p>
<p>I generally find giving people finished proofs uninformative and unhelpful.</p>
<p class="last">This seems like something to do from scratch in an emacs buffer. Trying
to capture that kind of interaction in the current format seems very
hard.</p>
</div>
<p>We prove progress and preservation for STLC. The <strong>progress</strong> theorem
tells us that closed, well-typed terms do not produce (immediate)
dynamic typing errors: either a well-typed term is a value, or it can
take an evaluation step. The proof is a relatively straightforward
induction.</p>
<pre class="code fstar literal-block">
val progress : e:exp -&gt; Lemma
      (requires (Some? (typing empty e)))
      (ensures (is_value e \/ (Some? (step e))))
let rec progress e =
  match e with
  | EApp e1 e2 -&gt; progress e1; progress e2
  | EIf e1 e2 e3 -&gt; progress e1; progress e2; progress e3
  | _ -&gt; ()
</pre>
<p>Variables are not well-typed in the empty environment, so the theorem
holds vacuously for variables. Boolean constants and abstractions are
values, so the theorem holds trivially for these. All these simple cases
are proved automatically by F<sup>★</sup>. For the remaining cases we need to use
the induction hypothesis, but otherwise the proofs are fully automated.
Under the hood F<sup>★</sup> and Z3 are doing quite a bit of work though.</p>
<p>In case <code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">(EApp</span> <span class="pre">e1</span> <span class="pre">e2)</span></code> F<sup>★</sup> and Z3 automate the following intuitive
argument: We case split on the first instance of the induction
hypothesis <code class="docutils literal"><span class="pre">(is_value</span> <span class="pre">e1</span> <span class="pre">\/</span> <span class="pre">(Some?</span> <span class="pre">(step</span> <span class="pre">e1)))</span></code>.</p>
<ul class="simple">
<li>If <code class="docutils literal"><span class="pre">e1</span></code> steps to <code class="docutils literal"><span class="pre">e1'</span></code> then, by the definition of <code class="docutils literal"><span class="pre">step</span></code>,
<code class="docutils literal"><span class="pre">(EApp</span> <span class="pre">e1</span> <span class="pre">e2)</span></code> steps to <code class="docutils literal"><span class="pre">(EApp</span> <span class="pre">e1'</span> <span class="pre">e2)</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">e1</span></code> is a value, we case split on the second induction
hypothesis instance, <code class="docutils literal"><span class="pre">(is_value</span> <span class="pre">e2</span> <span class="pre">\/</span> <span class="pre">(Some?</span> <span class="pre">(step</span> <span class="pre">e2)))</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">e2</span></code> steps to <code class="docutils literal"><span class="pre">e2'</span></code> then <code class="docutils literal"><span class="pre">(EApp</span> <span class="pre">e1</span> <span class="pre">e2)</span></code> steps to
<code class="docutils literal"><span class="pre">(EApp</span> <span class="pre">e1</span> <span class="pre">e2')</span></code>, since <code class="docutils literal"><span class="pre">e1</span></code> is a value.</li>
<li>If <code class="docutils literal"><span class="pre">e2</span></code> is also a value, then we need to obtain that <code class="docutils literal"><span class="pre">e1</span></code> has a
function type and from this that it is an abstraction. Expression
<code class="docutils literal"><span class="pre">e1</span></code> has a function type because, by the definition of <code class="docutils literal"><span class="pre">typing</span></code>,
an application is well-typed only when the first expression is a
function. The remaining step is usually done as a separate &#8220;canonical
forms&#8221; lemma, stating that any value that has a function type is
actually an abstraction. Z3 can prove this fact automatically from
the definitions of <code class="docutils literal"><span class="pre">typing</span></code> and <code class="docutils literal"><span class="pre">is_value</span></code>.</li>
</ul>
<p>The intuitive proof of the <code class="docutils literal"><span class="pre">EIf</span></code> case is similar.</p>
<p>The <strong>preservation</strong> theorem (sometimes also called &#8220;subject reduction&#8221;)
states that when a well-typed expression takes a step, the result is a
well-typed expression of the same type. In order to show preservation we
need to prove a couple of auxiliary results for reasoning about
variables and substitution.</p>
<p>The case for function application has to reason about &#8220;beta reduction&#8221;
steps, i.e. substituting the formal argument of a function with an
actual value. To see that this step preserves typing, we need to know
that the substitution itself does. So we prove a <strong>substitution</strong> lemma,
stating that substituting a (closed) term <code class="docutils literal"><span class="pre">v</span></code> for a variable <code class="docutils literal"><span class="pre">x</span></code> in
an expression <code class="docutils literal"><span class="pre">e</span></code> preserves the type of <code class="docutils literal"><span class="pre">e</span></code>. The tricky cases in the
substitution proof are the ones for variables and for function
abstractions. In both cases, we discover that we need to take an
expression <code class="docutils literal"><span class="pre">e</span></code> that has been shown to be well-typed in some context
<code class="docutils literal"><span class="pre">g</span></code> and consider the same expression <code class="docutils literal"><span class="pre">e</span></code> in a slightly different
context <code class="docutils literal"><span class="pre">g'</span></code>. For this we prove a <strong>context invariance</strong> lemma,
showing that typing is preserved under &#8220;inessential changes&#8221; to the
context <code class="docutils literal"><span class="pre">g</span></code>—in particular, changes that do not affect any of the free
variables of the expression. For this, we need a definition of the free
variables of an expression—i.e., the variables occurring in the
expression that are not bound by an abstraction.</p>
<p>A variable <code class="docutils literal"><span class="pre">x</span></code> appears free in <code class="docutils literal"><span class="pre">e</span></code> if <code class="docutils literal"><span class="pre">e</span></code> contains some occurrence
of <code class="docutils literal"><span class="pre">x</span></code> that is not under an abstraction labeled <code class="docutils literal"><span class="pre">x</span></code>:</p>
<pre class="code fstar literal-block">
val appears_free_in : x:int -&gt; e:exp -&gt; Tot bool
let rec appears_free_in x e =
  match e with
  | EVar y -&gt; x = y
  | EApp e1 e2 -&gt; appears_free_in x e1 || appears_free_in x e2
  | EAbs y _ e1 -&gt; x &lt;&gt; y &amp;&amp; appears_free_in x e1
  | EIf e1 e2 e3 -&gt;
      appears_free_in x e1 || appears_free_in x e2 || appears_free_in x e3
  | ETrue
  | EFalse -&gt; false
</pre>
<p>We also need a technical lemma connecting free variables and typing
contexts. If a variable <code class="docutils literal"><span class="pre">x</span></code> appears free in an expression <code class="docutils literal"><span class="pre">e</span></code>, and
if we know that <code class="docutils literal"><span class="pre">e</span></code> is well typed in context <code class="docutils literal"><span class="pre">g</span></code>, then it must be
the case that <code class="docutils literal"><span class="pre">g</span></code> assigns some type to <code class="docutils literal"><span class="pre">x</span></code>.</p>
<pre class="code fstar literal-block">
val free_in_context : x:int -&gt; e:exp -&gt; g:env -&gt; Lemma
      (requires (Some? (typing g e)))
      (ensures (appears_free_in x e ==&gt; Some? (g x)))
let rec free_in_context x e g =
  match e with
  | EVar _
  | ETrue
  | EFalse -&gt; ()
  | EAbs y t e1 -&gt; free_in_context x e1 (extend g y t)
  | EApp e1 e2 -&gt; free_in_context x e1 g; free_in_context x e2 g
  | EIf e1 e2 e3 -&gt; free_in_context x e1 g;
                    free_in_context x e2 g; free_in_context x e3 g
</pre>
<p>The proof is a straightforward induction. As a corollary for
<code class="docutils literal"><span class="pre">g</span> <span class="pre">==</span> <span class="pre">empty</span></code> we obtain that expressions typable in the empty
environment have no free variables.</p>
<pre class="code fstar literal-block">
val typable_empty_closed : x:int -&gt; e:exp -&gt; Lemma
      (requires (Some? (typing empty e)))
      (ensures (not(appears_free_in x e)))
      [SMTPat (appears_free_in x e)]
let typable_empty_closed x e = free_in_context x e empty
</pre>
<p>The quantifier pattern <code class="docutils literal"><span class="pre">[SMTPat</span> <span class="pre">(appears_free_in</span> <span class="pre">x</span> <span class="pre">e)]</span></code> signals to Z3
that it should consider applying this lemma when its context contains a
term of the form <code class="docutils literal"><span class="pre">appears_free_in</span></code></p>
<p>Sometimes, we know that <code class="docutils literal"><span class="pre">typing</span> <span class="pre">g</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">t</span></code>, and we will need to
replace <code class="docutils literal"><span class="pre">g</span></code> by an &#8220;equivalent&#8221; context <code class="docutils literal"><span class="pre">g'</span></code>. We still need to define
formally when two environments are equivalent. A natural definition is
extensional equivalence of functions:</p>
<pre class="code fstar literal-block">
logic type equal (g1:env) (g2:env) = forall (x:int). g1 x = g2 x
</pre>
<p>According to this definition two environments are equivalent if have the
same domain and they map all variables in the domain to the same type.
We remark <code class="docutils literal"><span class="pre">equal</span></code> in particular and logical formulas in general are
<em>types</em> in F<sup>★</sup>, thus the different syntax for this definition.</p>
<div class="admonition-fixme admonition">
<p class="first admonition-title">FIXME (Cătălin)</p>
<p class="last">What does opaque do exactly? What does logic do? Hints for the SMT
solver / logical encoding only?</p>
</div>
<p>The context invariance lemma uses in fact a weaker variant of this
equivalence in which the two environments only need to agree on the
variables that appear free in an expression <code class="docutils literal"><span class="pre">e</span></code>:</p>
<pre class="code fstar literal-block">
logic type equalE (e:exp) (g1:env) (g2:env) =
  forall (x:int). appears_free_in x e ==&gt; g1 x = g2 x
</pre>
<p>The context invariance lemma is then easily proved by induction:</p>
<pre class="code fstar literal-block">
val context_invariance : e:exp -&gt; g:env -&gt; g':env -&gt; Lemma
  (requires (equalE e g g'))
  (ensures (typing g e == typing g' e))
let rec context_invariance e g g' =
  match e with
  | EAbs x t e1 -&gt;
     context_invariance e1 (extend g x t) (extend g' x t)

  | EApp e1 e2 -&gt;
     context_invariance e1 g g';
     context_invariance e2 g g'

  | EIf e1 e2 e3 -&gt;
     context_invariance e1 g g';
     context_invariance e2 g g';
     context_invariance e3 g g'

  | _ -&gt; ()
</pre>
<p>Because <code class="docutils literal"><span class="pre">equal</span></code> is a stronger relation than <code class="docutils literal"><span class="pre">equalE</span></code> we obtain the
same property for <code class="docutils literal"><span class="pre">equal</span></code>:</p>
<pre class="code fstar literal-block">
val typing_extensional : g:env -&gt; g':env -&gt; e:exp -&gt; Lemma
  (requires (equal g g'))
  (ensures (typing g e == typing g' e))
let typing_extensional g g' e = context_invariance e g g'
</pre>
<p>We can use these results to show the following substitution lemma:</p>
<pre class="code fstar literal-block">
val substitution_preserves_typing : x:int -&gt; e:exp -&gt; v:exp -&gt; g:env -&gt; Lemma
  (requires (Some? (typing empty v) /\
             Some? (typing (extend g x (Some?.v (typing empty v))) e)))
  (ensures (Some? (typing empty v) /\
            typing g (subst x v e) ==
            typing (extend g x (Some?.v (typing empty v))) e))
let rec substitution_preserves_typing x e v g =
  let Some t_x = typing empty v in
  let gx = extend g x t_x in
  match e with
  | ETrue -&gt; ()
  | EFalse -&gt; ()
  | EVar y -&gt;
     if x=y
     then context_invariance v empty g (* uses lemma typable_empty_closed *)
     else context_invariance e gx g

  | EApp e1 e2 -&gt;
     substitution_preserves_typing x e1 v g;
     substitution_preserves_typing x e2 v g

  | EIf e1 e2 e3 -&gt;
     substitution_preserves_typing x e1 v g;
     substitution_preserves_typing x e2 v g;
     substitution_preserves_typing x e3 v g

  | EAbs y t_y e1 -&gt;
     let gxy = extend gx y t_y in
     let gy = extend g y t_y in
     if x=y
     then typing_extensional gxy gy e1
     else
       (let gyx = extend gy x t_x in
        typing_extensional gxy gyx e1;
        substitution_preserves_typing x e1 v gy)
</pre>
<p>The proof proceeds by induction on the expression <code class="docutils literal"><span class="pre">e</span></code>; we give the
intuition of the two most interesting cases:</p>
<ul>
<li><p class="first">Case <code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">EVar</span> <span class="pre">y</span></code></p>
</li>
<li><p class="first">Case <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>: We have <code class="docutils literal"><span class="pre">subst</span> <span class="pre">x</span> <span class="pre">v</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">v</span></code> and we already know that
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">empty</span> <span class="pre">v</span> <span class="pre">==</span> <span class="pre">Some</span> <span class="pre">t_x</span></code>. However, what we need to show is
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">g</span> <span class="pre">v</span> <span class="pre">==</span> <span class="pre">Some</span> <span class="pre">t_x</span></code> for some arbitrary environment <code class="docutils literal"><span class="pre">g</span></code>. From
the <code class="docutils literal"><span class="pre">typable_empty_closed</span></code> lemma we obtain that <code class="docutils literal"><span class="pre">v</span></code> contains no
free variables, so we have <code class="docutils literal"><span class="pre">equalE</span> <span class="pre">v</span> <span class="pre">empty</span> <span class="pre">g</span></code>. This allows us to
apply the <code class="docutils literal"><span class="pre">context_invariance</span></code> lemma to obtain that
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">empty</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">typing</span> <span class="pre">g</span> <span class="pre">v</span></code> and complete the proof of this case.</p>
</li>
<li><p class="first">Case <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&gt;</span> <span class="pre">y</span></code> We have <code class="docutils literal"><span class="pre">subst</span> <span class="pre">x</span> <span class="pre">v</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">e</span></code> and
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">gx</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">t_e</span></code> and need to show that</p>
<div class="code highlight-ocaml"><div class="highlight"><pre><span></span><span class="n">typing</span> <span class="n">g</span> <span class="n">e</span> <span class="o">==</span> <span class="nc">Some</span> <span class="n">t_e</span>
</pre></div>
</div>
<p>We have that <code class="docutils literal"><span class="pre">EquivE</span> <span class="pre">(EVar</span> <span class="pre">y)</span> <span class="pre">gx</span> <span class="pre">g</span></code> since <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&gt;</span> <span class="pre">y</span></code> so we can
apply the <code class="docutils literal"><span class="pre">context_invariance</span></code> lemma to conclude.</p>
</li>
<li><p class="first">Case <code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">EAbs</span> <span class="pre">y</span> <span class="pre">t_y</span> <span class="pre">e1</span></code>: We have that
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">gxy</span> <span class="pre">e1</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">t_e1</span></code>, and need to show that
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">gy</span> <span class="pre">e1</span> <span class="pre">==</span> <span class="pre">Some</span> <span class="pre">t_e1</span></code></p>
</li>
<li><p class="first">Case <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> We have <code class="docutils literal"><span class="pre">subst</span> <span class="pre">x</span> <span class="pre">v</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">EAbs</span> <span class="pre">y</span> <span class="pre">t_y</span> <span class="pre">e1</span></code>. Since
<code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> the <code class="docutils literal"><span class="pre">x</span></code> binder in <code class="docutils literal"><span class="pre">gxy</span></code> is spurious (we have
<code class="docutils literal"><span class="pre">equal</span> <span class="pre">gy</span> <span class="pre">gxy</span></code>) and can apply the <code class="docutils literal"><span class="pre">typing_extensional</span></code> lemma.</p>
</li>
<li><p class="first">Case <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&gt;</span> <span class="pre">y</span></code> We have <code class="docutils literal"><span class="pre">subst</span> <span class="pre">x</span> <span class="pre">v</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">EAbs</span> <span class="pre">y</span> <span class="pre">t_y</span> <span class="pre">(subst</span> <span class="pre">x</span> <span class="pre">v</span> <span class="pre">e1)</span></code>.
Since <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&gt;</span> <span class="pre">y</span></code> (and since we are in a simply typed calculus, not a
dependently typed one) we can swap the <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> binding to
show that <code class="docutils literal"><span class="pre">equal</span> <span class="pre">gxy</span> <span class="pre">xyx</span></code>. By the <code class="docutils literal"><span class="pre">typing_extensional</span></code> lemma we
obtain that <code class="docutils literal"><span class="pre">typing</span> <span class="pre">gxy</span> <span class="pre">e1</span> <span class="pre">==</span> <span class="pre">typing</span> <span class="pre">gyx</span> <span class="pre">e1</span></code>. By the induction
hypothesis we thus obtain that</p>
<div class="code highlight-ocaml"><div class="highlight"><pre><span></span><span class="n">typing</span> <span class="n">gy</span> <span class="o">(</span><span class="n">subst</span> <span class="n">x</span> <span class="n">v</span> <span class="n">e1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Some</span> <span class="n">t_e1</span>
</pre></div>
</div>
<p>and by the definition of <code class="docutils literal"><span class="pre">typing</span></code> we conclude that
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">g</span> <span class="pre">(EAbs</span> <span class="pre">y</span> <span class="pre">t_y</span> <span class="pre">(subst</span> <span class="pre">x</span> <span class="pre">v</span> <span class="pre">e))</span> <span class="pre">=</span> <span class="pre">t_e</span></code>.</p>
</li>
</ul>
<p>We now have the tools we need to prove preservation: if a closed
expression <code class="docutils literal"><span class="pre">e</span></code> has type <code class="docutils literal"><span class="pre">t</span></code> and takes an evaluation step to <code class="docutils literal"><span class="pre">e'</span></code>,
then <code class="docutils literal"><span class="pre">e'</span></code> is also a closed expression with type <code class="docutils literal"><span class="pre">t</span></code>. In other words,
the small-step evaluation relation preserves types.</p>
<pre class="code fstar literal-block">
val preservation : e:exp -&gt; Lemma
  (requires (Some? (typing empty e) /\ Some? (step e) ))
  (ensures (Some? (step e) /\
            typing empty (Some?.v (step e)) == typing empty e))
let rec preservation e =
  match e with
  | EApp e1 e2 -&gt;
     if is_value e1
     then (if is_value e2
           then let EAbs x _ ebody = e1 in
                substitution_preserves_typing x ebody e2 empty
           else preservation e2)
     else preservation e1

  | EIf e1 _ _ -&gt;
      if not (is_value e1) then preservation e1
</pre>
<p>We only have two cases to consider, since only applications and
conditionals can take successful execution steps. The case for
<code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">EIf</span> <span class="pre">e1</span> <span class="pre">e2</span> <span class="pre">e3</span></code> is simple: either <code class="docutils literal"><span class="pre">e1</span></code> is a value and thus the
conditional reduces to <code class="docutils literal"><span class="pre">e2</span></code> or <code class="docutils literal"><span class="pre">e3</span></code> which by the typing hypothesis
also have type <code class="docutils literal"><span class="pre">t</span></code>, or <code class="docutils literal"><span class="pre">e1</span></code> takes a successful step and we can apply
the induction hypothesis. We use the <code class="docutils literal"><span class="pre">Some?.v</span></code> projector, which
requires F<sup>★</sup> to prove that indeed <code class="docutils literal"><span class="pre">e1</span></code> can take a step; this is
immediate since we know that the whole conditional takes a step and we
know that <code class="docutils literal"><span class="pre">e1</span></code> is not a value.</p>
<p>The case for <code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">EApp</span> <span class="pre">e1</span> <span class="pre">e2</span></code> is a bit more complex. If <code class="docutils literal"><span class="pre">e1</span></code> steps
or if <code class="docutils literal"><span class="pre">e1</span></code> is a value and <code class="docutils literal"><span class="pre">e2</span></code> steps then we just apply the
induction hypothesis. If both <code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e2</span></code> are values it needs to
be the case that <code class="docutils literal"><span class="pre">e1</span></code> is an abstraction <code class="docutils literal"><span class="pre">EAbs</span> <span class="pre">x</span> <span class="pre">targ</span> <span class="pre">ebody</span></code> and
<code class="docutils literal"><span class="pre">step</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">subst</span> <span class="pre">x</span> <span class="pre">e2</span> <span class="pre">ebody</span></code>. From the typing assumption we have
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">(extend</span> <span class="pre">empty</span> <span class="pre">x</span> <span class="pre">tags)</span> <span class="pre">ebody</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">t</span></code> and
<code class="docutils literal"><span class="pre">typing</span> <span class="pre">empty</span> <span class="pre">e2</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">targ</span></code>, so we can use the substitution lemma to
obtain that <code class="docutils literal"><span class="pre">typing</span> <span class="pre">empty</span> <span class="pre">(subst</span> <span class="pre">x</span> <span class="pre">e2</span> <span class="pre">ebody)</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">t</span></code>, which
concludes the proof.</p>
</div>
<div class="section" id="exercises-for-stlc">
<h2>Exercises for STLC<a class="headerlink" href="#exercises-for-stlc" title="Permalink to this headline">¶</a></h2>
<div class="exercise container">
<div class="exercise-header container">
<span class="exercise-label">Exercise</span><span class="exercise-title">Typed steps</span></div>
<p>Define a <code class="docutils literal"><span class="pre">typed_step</span></code> step function that takes a well-typed expression
<code class="docutils literal"><span class="pre">e</span></code> that is not a value and produces the expression to which <code class="docutils literal"><span class="pre">e</span></code>
steps. Give <code class="docutils literal"><span class="pre">typed_step</span></code> the following strong type (basically this
type captures both progress and preservation):</p>
<pre class="code fstar literal-block">
val typed_step : e:exp{Some? (typing empty e) /\ not(is_value e)} -&gt;
                 Tot (e':exp{typing empty e' = typing empty e})
</pre>
<p>(Hint: the most direct solution to this exercise fits on one line)</p>
<div class="solution container">
<div class="solution-header container">
<span class="solution-label">Solution</span></div>
<pre class="code fstar literal-block">
let typed_step e = progress e; preservation e; Some?.v (step e)
</pre>
</div>
</div>
<div class="exercise container">
<div class="exercise-header container">
<span class="exercise-label">Exercise</span><span class="exercise-title">Pairs</span></div>
<p>To add pairs to this formal development we add the following to the
definition of types, expressions, values, substitution, and step:</p>
<pre class="code fstar literal-block">
type tyP =
  (* {{{ 2 unchanged cases omitted *)
  | TBoolP  : tyP
  | TArrowP : tin:tyP -&gt; tout:tyP -&gt; tyP
  (* }}} *)
  | TPairP : tyP -&gt; tyP -&gt; tyP

type expP =
  (* {{{ 6 unchanged cases omitted *)
  | EVarP   : v:var -&gt; expP
  | EAppP   : fn:expP -&gt; arg:expP -&gt; expP
  | EAbsP   : v:var -&gt; vty:tyP -&gt; body:expP -&gt; expP
  | ETrueP  : expP
  | EFalseP : expP
  | EIfP    : test:expP -&gt; btrue:expP -&gt; bfalse:expP -&gt; expP
  (* }}} *)
  | EPairP  : expP -&gt; expP -&gt; expP
  | EFstP   : expP -&gt; expP
  | ESndP   : expP -&gt; expP

let rec is_valueP e = (* Note the extra let rec! *)
  match e with
  (* {{{ 3 unchanged cases omitted *)
  | EAbsP _ _ _
  | ETrueP
  | EFalseP     -&gt; true
  (* }}} *)
  | EPairP e1 e2 -&gt; is_valueP e1 &amp;&amp; is_valueP e2
  | _ -&gt; false

let rec substP x e e' =
  match e' with
  (* {{{ 6 unchanged cases omitted *)
  | EVarP x' -&gt; if x = x' then e else e'
  | EAbsP x' t e1 -&gt;
      EAbsP x' t (if x = x' then e1 else (substP x e e1))
  | EAppP e1 e2 -&gt; EAppP (substP x e e1) (substP x e e2)
  | ETrueP -&gt; ETrueP
  | EFalseP -&gt; EFalseP
  | EIfP e1 e2 e3 -&gt; EIfP (substP x e e1) (substP x e e2) (substP x e e3)
  (* }}} *)
  | EPairP e1 e2 -&gt; EPairP (substP x e e1) (substP x e e2)
  | EFstP e1 -&gt; EFstP (substP x e e1)
  | ESndP e1 -&gt; ESndP (substP x e e1)

let rec stepP e =
  match e with
  (* {{{ 2 unchanged cases omitted *)
  | EAppP e1 e2 -&gt;
      if is_valueP e1 then
        if is_valueP e2 then
          match e1 with
          | EAbsP x t e' -&gt; Some (substP x e2 e')
          | _           -&gt; None
        else
          match (stepP e2) with
          | Some e2' -&gt; Some (EAppP e1 e2')
          | None     -&gt; None
      else
        (match (stepP e1) with
        | Some e1' -&gt; Some (EAppP e1' e2)
        | None     -&gt; None)
  | EIfP e1 e2 e3 -&gt;
      if is_valueP e1 then
        match e1 with
        | ETrueP   -&gt; Some e2
        | EFalseP  -&gt; Some e3
        | _       -&gt; None
      else
        (match (stepP e1) with
        | Some e1' -&gt; Some (EIfP e1' e2 e3)
        | None     -&gt; None)
  (* }}} *)
  | EPairP e1 e2 -&gt;
      if is_valueP e1 then
        if is_valueP e2 then None
        else
          (match (stepP e2) with
          | Some e2' -&gt; Some (EPairP e1 e2')
          | None     -&gt; None)
      else
        (match (stepP e1) with
        | Some e1' -&gt; Some (EPairP e1' e2)
        | None     -&gt; None)
  | EFstP e1 -&gt;
      if is_valueP e1 then
        (match e1 with
        | EPairP v1 v2 -&gt; Some v1
        | _           -&gt; None)
      else
        (match (stepP e1) with
        | Some e1' -&gt; Some (EFstP e1')
        | None     -&gt; None)
  | ESndP e1 -&gt;
      if is_valueP e1 then
        (match e1 with
        | EPairP v1 v2 -&gt; Some v2
        | _           -&gt; None)
      else
        (match (stepP e1) with
        | Some e1' -&gt; Some (ESndP e1')
        | None     -&gt; None)
  | _ -&gt; None
</pre>
<p>Add cases to <code class="docutils literal"><span class="pre">typingP</span></code> for the new constructs and fix all the proofs.</p>
<div class="solution container">
<div class="solution-header container">
<span class="solution-label">Solution</span></div>
<p>We extend the <code class="docutils literal"><span class="pre">typingP</span></code> and <code class="docutils literal"><span class="pre">appears_free_inP</span></code> functions with cases
for <code class="docutils literal"><span class="pre">EPairP</span></code>, <code class="docutils literal"><span class="pre">EFstP</span></code>, and <code class="docutils literal"><span class="pre">ESndP</span></code>:</p>
<pre class="code fstar literal-block">
type envP = int -&gt; Tot (option tyP)

val emptyP : envP
let emptyP = fun _ -&gt; None
</pre>
<p>When we move under a binder we extend the typing environment.</p>
<pre class="code fstar literal-block">
val extendP : envP -&gt; int -&gt; tyP -&gt; Tot envP
let extendP g x t = fun x' -&gt; if x = x' then Some t else g x'

val typingP : envP -&gt; expP -&gt; Tot (option tyP)
let rec typingP g e =
  match e with
  (* {{{ 6 unchanged cases omitted *)
  | EVarP x -&gt; g x
  | EAbsP x t e1 -&gt;
      (match typingP (extendP g x t) e1 with
      | Some t' -&gt; Some (TArrowP t t')
      | None    -&gt; None)
  | EAppP e1 e2 -&gt;
      (match typingP g e1, typingP g e2 with
      | Some (TArrowP t11 t12), Some t2 -&gt; if t11 = t2 then Some t12 else None
      | _                    , _       -&gt; None)
  | ETrueP  -&gt; Some TBoolP
  | EFalseP -&gt; Some TBoolP
  | EIfP e1 e2 e3 -&gt;
      (match typingP g e1, typingP g e2, typingP g e3 with
      | Some TBoolP, Some t2, Some t3 -&gt; if t2 = t3 then Some t2 else None
      | _         , _      , _       -&gt; None)

  (* }}} *)
  | EPairP e1 e2 -&gt;
      (match typingP g e1, typingP g e2 with
      | Some t1, Some t2 -&gt; Some (TPairP t1 t2)
      | _      , _       -&gt; None)
  | EFstP e1 -&gt;
      (match typingP g e1 with
      | Some (TPairP t1 t2) -&gt; Some t1
      | _                  -&gt; None)
  | ESndP e1 -&gt;
      (match typingP g e1 with
      | Some (TPairP t1 t2) -&gt; Some t2
      | _                  -&gt; None)

val appears_free_inP : x:int -&gt; e:expP -&gt; Tot bool
let rec appears_free_inP x e =
  match e with
  (* {{{ 6 unchanged cases omitted *)
  | EVarP y -&gt; x = y
  | EAppP e1 e2 -&gt; appears_free_inP x e1 || appears_free_inP x e2
  | EAbsP y _ e1 -&gt; x &lt;&gt; y &amp;&amp; appears_free_inP x e1
  | EIfP e1 e2 e3 -&gt;
      appears_free_inP x e1 || appears_free_inP x e2 || appears_free_inP x e3
  | ETrueP
  | EFalseP -&gt; false
  (* }}} *)
  | EPairP e1 e2 -&gt; appears_free_inP x e1 || appears_free_inP x e2
  | EFstP e1 -&gt; appears_free_inP x e1
  | ESndP e1 -&gt; appears_free_inP x e1
</pre>
<p>The proofs of the lemmas are also easy to extend by just calling the
induction hypothesis:</p>
<pre class="code fstar literal-block">
val free_in_contextP : x:int -&gt; e:expP -&gt; g:envP -&gt; Lemma
      (requires (Some? (typingP g e)))
      (ensures (appears_free_inP x e ==&gt; Some? (g x)))
let rec free_in_contextP x e g =
  match e with
  (* {{{ 6 unchanged cases omitted *)
  | EVarP _
  | ETrueP
  | EFalseP -&gt; ()
  | EAbsP y t e1 -&gt; free_in_contextP x e1 (extendP g y t)
  | EAppP e1 e2 -&gt; free_in_contextP x e1 g; free_in_contextP x e2 g
  | EIfP e1 e2 e3 -&gt; free_in_contextP x e1 g;
                    free_in_contextP x e2 g; free_in_contextP x e3 g
  (* }}} *)
  | EPairP e1 e2 -&gt; free_in_contextP x e1 g; free_in_contextP x e2 g
  | EFstP e1
  | ESndP e1 -&gt; free_in_contextP x e1 g

logic type equalEP (e:expP) (g1:envP) (g2:envP) =
  forall (x:int). appears_free_inP x e ==&gt; g1 x = g2 x

val context_invarianceP : e:expP -&gt; g:envP -&gt; g':envP -&gt; Lemma
  (requires (equalEP e g g'))
  (ensures (typingP g e == typingP g' e))
let rec context_invarianceP e g g' =
  match e with
  (* {{{ 3 unchanged cases omitted *)
  | EAbsP x t e1 -&gt;
     context_invarianceP e1 (extendP g x t) (extendP g' x t)

  | EAppP e1 e2 -&gt;
     context_invarianceP e1 g g';
     context_invarianceP e2 g g'

  | EIfP e1 e2 e3 -&gt;
     context_invarianceP e1 g g';
     context_invarianceP e2 g g';
     context_invarianceP e3 g g'
  (* }}} *)

  | EPairP e1 e2 -&gt;
     context_invarianceP e1 g g';
     context_invarianceP e2 g g'

  | EFstP e1
  | ESndP e1 -&gt; context_invarianceP e1 g g'

  | _ -&gt; ()

(* {{{ similar definitions skipped *)
logic type equalP (g1:envP) (g2:envP) = forall (x:int). g1 x = g2 x

val typing_extensionalP : g:envP -&gt; g':envP -&gt; e:expP -&gt; Lemma
  (requires (equalP g g'))
  (ensures (typingP g e == typingP g' e))
let typing_extensionalP g g' e = context_invarianceP e g g'

val typable_empty_closedP : x:int -&gt; e:expP -&gt; Lemma
      (requires (Some? (typingP emptyP e)))
      (ensures (not(appears_free_inP x e)))
      [SMTPat (appears_free_inP x e)]
let typable_empty_closedP x e = free_in_contextP x e emptyP
(* }}} *)

val substitution_preserves_typingP : x:int -&gt; e:expP -&gt; v:expP -&gt; g:envP -&gt; Lemma
  (requires (Some? (typingP emptyP v) /\
             Some? (typingP (extendP g x (Some?.v (typingP emptyP v))) e)))
  (ensures (Some? (typingP emptyP v) /\
            typingP g (substP x v e) ==
            typingP (extendP g x (Some?.v (typingP emptyP v))) e))
let rec substitution_preserves_typingP x e v g =
  (* {{{ unchanged preamble skipped *)
  let Some t_x = typingP emptyP v in
  let gx = extendP g x t_x in
  match e with
  | ETrueP -&gt; ()
  | EFalseP -&gt; ()
  | EVarP y -&gt;
     if x=y
     then context_invarianceP v emptyP g (* uses lemma typable_empty_closed *)
     else context_invarianceP e gx g

  | EAppP e1 e2 -&gt;
     substitution_preserves_typingP x e1 v g;
     substitution_preserves_typingP x e2 v g

  | EIfP e1 e2 e3 -&gt;
     substitution_preserves_typingP x e1 v g;
     substitution_preserves_typingP x e2 v g;
     substitution_preserves_typingP x e3 v g

  | EAbsP y t_y e1 -&gt;
     let gxy = extendP gx y t_y in
     let gy = extendP g y t_y in
     if x=y
     then typing_extensionalP gxy gy e1
     else
       (let gyx = extendP gy x t_x in
        typing_extensionalP gxy gyx e1;
        substitution_preserves_typingP x e1 v gy)
  (* }}} *)

  | EPairP e1 e2 -&gt;
     (substitution_preserves_typingP x e1 v g;
      substitution_preserves_typingP x e2 v g)

  | EFstP e1
  | ESndP e1 -&gt;
      substitution_preserves_typingP x e1 v g

  | _ -&gt; ()
</pre>
<p>As for the other cases, the preservation proof when <code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">EPair</span> <span class="pre">e1</span> <span class="pre">e2</span></code>
follows the structure of the <code class="docutils literal"><span class="pre">step</span></code> function. If <code class="docutils literal"><span class="pre">e1</span></code> is not a value
then it further evaluates, so we apply the induction hypothesis to
<code class="docutils literal"><span class="pre">e1</span></code>. If <code class="docutils literal"><span class="pre">e1</span></code> is a value, then since we know that the pair
evaluates, it must be the case that <code class="docutils literal"><span class="pre">e2</span></code> is not a value and further
evaluates, so we apply the induction hypothesis to it. The cases for
<code class="docutils literal"><span class="pre">EFst</span></code> and <code class="docutils literal"><span class="pre">ESnd</span></code> are similar.</p>
<pre class="code fstar literal-block">
val preservationP : e:expP{Some? (typingP emptyP e) /\ Some? (stepP e)} -&gt;
      Tot (u:unit{typingP emptyP (Some?.v (stepP e)) == typingP emptyP e})
let rec preservationP e =
  match e with
  (* {{{ two unchanged cases *)
  | EAppP e1 e2 -&gt;
     if is_valueP e1
     then (if is_valueP e2
           then let EAbsP x _ ebody = e1 in
                substitution_preserves_typingP x ebody e2 emptyP
           else preservationP e2)
     else preservationP e1

  | EIfP e1 _ _ -&gt;
      if not (is_valueP e1) then preservationP e1
  (* }}} *)

  | EPairP e1 e2 -&gt;
      (match is_valueP e1, is_valueP e2 with
      | false, _     -&gt; preservationP e1
      | true , false -&gt; preservationP e2)

  | EFstP e1
  | ESndP e1 -&gt;
      if not (is_valueP e1) then preservationP e1
</pre>
</div>
</div>
<div class="exercise container">
<div class="exercise-header container">
<span class="exercise-label">Exercise</span><span class="exercise-title">Let bindings</span></div>
<p>We want to add a let construct to this formal development. We add the
following to the definition of expressions:</p>
<div class="code highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">exp</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="o">|</span> <span class="nc">ELet</span>  <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">exp</span> <span class="o">-&gt;</span> <span class="n">exp</span> <span class="o">-&gt;</span> <span class="n">exp</span>
</pre></div>
</div>
<p>Add cases for <code class="docutils literal"><span class="pre">ELet</span></code> to all definitions and proofs.</p>
<div class="admonition-fixme admonition">
<p class="first admonition-title">FIXME (Cătălin)</p>
<p class="last">Make the prev kind of link a macro of some sorts. It doesn&#8217;t have a
proper body so it&#8217;s not an environment, but what is it? Entity?</p>
</div>
</div>
<div class="exercise container">
<div class="exercise-header container">
<span class="exercise-label">Exercise</span><span class="exercise-title">Big-step interpretation</span></div>
<p>Define a big-step interpreter for STLC as a recursive function <code class="docutils literal"><span class="pre">eval</span></code>
that given a well-typed expression <code class="docutils literal"><span class="pre">e</span></code> either produces the well-typed
value <code class="docutils literal"><span class="pre">v</span></code> to which <code class="docutils literal"><span class="pre">e</span></code> evaluates or it diverges if the evaluation of
<code class="docutils literal"><span class="pre">e</span></code> loops. Give <code class="docutils literal"><span class="pre">eval</span></code> the following strong type ensuring that <code class="docutils literal"><span class="pre">v</span></code>
has the same type as <code class="docutils literal"><span class="pre">e</span></code> (basically this type captures both progress
and preservation):</p>
<pre class="code fstar literal-block">
val eval : e:exp{Some? (typing empty e)} -&gt;
           Dv (v:exp{is_value v &amp;&amp; typing empty v = typing empty e})
</pre>
<p>The <code class="docutils literal"><span class="pre">Dv</span></code> effect is that of potentially divergent computations. We
cannot mark this as <code class="docutils literal"><span class="pre">Tot</span></code> since <em>a priori</em> STLC computations could
loop, and it is hard to prove that well-typed ones don&#8217;t.</p>
<div class="solution container">
<div class="solution-header container">
<span class="solution-label">Solution</span></div>
<p>Here is a solution that only uses <code class="docutils literal"><span class="pre">typed_step</span></code> (suggested by Santiago
Zanella):</p>
<pre class="code fstar literal-block">
let rec eval e =
  if is_value e then e
  else eval (typed_step e)
</pre>
<p>or using the <code class="docutils literal"><span class="pre">progress</span></code> and <code class="docutils literal"><span class="pre">preservation</span></code> lemmas instead of
<code class="docutils literal"><span class="pre">typed_step</span></code> (suggested by Guido Martinez):</p>
<pre class="code fstar literal-block">
val eval' : e:exp{Some? (typing empty e)} -&gt;
  Dv (v:exp{is_value v &amp;&amp; typing empty v = typing empty e})
let rec eval' e = match step e with
  | None -&gt; progress e; e
  | Some e' -&gt; preservation e; eval' e'
</pre>
<p>Here is another solution that only uses the substitution lemma:</p>
<pre class="code fstar literal-block">
val eval'' : e:exp{Some? (typing empty e)} -&gt;
            Dv (v:exp{is_value v &amp;&amp; typing empty v = typing empty e})
let rec eval'' e =
  let Some t = typing empty e in
  match e with
  | EApp e1 e2 -&gt;
     (let EAbs x _ e' = eval' e1 in
      let v = eval' e2 in
      substitution_preserves_typing x e' v empty;
      eval'' (subst x v e'))
  | EAbs _ _ _
  | ETrue
  | EFalse     -&gt; e
  | EIf e1 e2 e3 -&gt;
     (match eval'' e1 with
      | ETrue  -&gt; eval'' e2
      | EFalse -&gt; eval'' e3)
</pre>

      <div id="footer">
        Assembled by <a href="http://pit-claudel.fr/clement/">Clément Pit-Claudel</a> by compiling <a href="https://github.com/Z3Prover/z3/commit/88e777748ad94c097ff8d2e00359107a9f4aba76">Z3</a> 4.6.2/88e7777 with <a href="http://kripken.github.io/emscripten-site/">Emscripten</a> and F* 0.9.5/93af610 with <a href="https://github.com/ocsigen/js_of_ocaml">js_of_ocaml</a>.
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/codemirror.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/addon/runmode/runmode.min.js" integrity="sha256-Y2iV9vZZs9GsyRIV5HgmKgmfGIsXHpdcknYcbIFkz4M=" crossorigin="anonymous"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mustache.js/2.3.0/mustache.js" integrity="sha256-XDU6Po3hKjdQXJHRrKrWlIF/E6y6BBgV5eiqZSYePpo=" crossorigin="anonymous"></script>

    <script src="./fstar.js/fstar.cm.js"></script>
    <script src="./fstar.js/fstar.client.js"></script>

    <script>
      FStar.IDE.LiterateClient.run("stlc.fst");

      if (document && document.fonts && document.fonts.ready) {
          // Normally added by fslit.js
          document.fonts.ready.then(function () {
              var editors = document.getElementsByClassName("CodeMirror");
              for (var idx = 0; idx < editors.length; idx++) {
                  var editor = editors[idx].CodeMirror;
                  editor && editor.refresh();
              }
          });
      }
    </script>
  </body>
</html>
