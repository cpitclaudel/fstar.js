/* global require global FStar */

if (typeof(require) !== "undefined") {
    process.chdir("../lib/");
    global.JSOO_FStar = require("../build/js/fstar.core.js");
    global.JSOO_FStar_Stdlib = require("../build/js/fstar.stdlib.js");
    global.underscore = require("../vendor/underscore-min.js");
    global.Z3 = require("../lib/z3-wasm.core.js");
    require("../lib/fstar.global-object.js");
    require("../lib/fstar.driver.js");
    require("../lib/fstar.ide.utils.js");
    require("../lib/fstar.smtdriver.js");
}

var fname = "stlc.fst";
var args = ["--z3refresh", "--fstar_home", "/fstar"]; // "--lax", "--admit_smt_queries", "true",

var fblocks = [
    "module STLC",
    "type ty =\n  | TBool  : ty\n  | TArrow : tin:ty -> tout:ty -> ty\n\ntype var = int",
    "type exp =\n  | EVar   : v:var -> exp\n  | EApp   : fn:exp -> arg:exp -> exp\n  | EAbs   : v:var -> vty:ty -> body:exp -> exp\n  | ETrue  : exp\n  | EFalse : exp\n  | EIf    : test:exp -> btrue:exp -> bfalse:exp -> exp",
    "let stlc_app_id_to_true = EApp (EAbs 0 TBool (EVar 0)) ETrue",
    "let stlc_not = EAbs 0 TBool (EIf (EVar 0) EFalse ETrue)",
    "val is_value : exp -> Tot bool\nlet is_value e =\n  match e with\n  | EAbs _ _ _\n  | ETrue\n  | EFalse     -> true\n  | _          -> false",
    "val subst : int -> exp -> exp -> Tot exp\nlet rec subst x e e' =\n  match e' with\n  | EVar x' -> if x = x' then e else e'\n  | EAbs x' t e1 ->\n      EAbs x' t (if x = x' then e1 else (subst x e e1))\n  | EApp e1 e2 -> EApp (subst x e e1) (subst x e e2)\n  | ETrue -> ETrue\n  | EFalse -> EFalse\n  | EIf e1 e2 e3 -> EIf (subst x e e1) (subst x e e2) (subst x e e3)",
    "val step : exp -> Tot (option exp)\n  let rec step e =\n  match e with\n  | EApp e1 e2 ->\n      if is_value e1 then\n        if is_value e2 then\n          match e1 with\n          | EAbs x t e' -> Some (subst x e2 e')\n          | _           -> None\n        else\n          match (step e2) with\n          | Some e2' -> Some (EApp e1 e2')\n          | None     -> None\n      else\n        (match (step e1) with\n        | Some e1' -> Some (EApp e1' e2)\n        | None     -> None)\n  | EIf e1 e2 e3 ->\n      if is_value e1 then\n        match e1 with\n        | ETrue   -> Some e2\n        | EFalse  -> Some e3\n        | _       -> None\n      else\n        (match (step e1) with\n        | Some e1' -> Some (EIf e1' e2 e3)\n        | None     -> None)\n  | _ -> None",
    "let _ = assert (step (EApp (EAbs 0 TBool (EVar 0)) ETrue) = Some ETrue)\nlet _ = assert (step (EApp ETrue ETrue) = None)",
    "type env = int -> Tot (option ty)",
    "val empty : env\nlet empty = fun _ -> None",
    "val extend : env -> int -> ty -> Tot env\nlet extend g x t = fun x' -> if x = x' then Some t else g x'",
    "val typing : env -> exp -> Tot (option ty)\nlet rec typing g e =\n  match e with\n  | EVar x -> g x\n  | EAbs x t e1 ->\n      (match typing (extend g x t) e1 with\n      | Some t' -> Some (TArrow t t')\n      | None    -> None)\n  | EApp e1 e2 ->\n      (match typing g e1, typing g e2 with\n      | Some (TArrow t11 t12), Some t2 -> if t11 = t2 then Some t12 else None\n      | _                    , _       -> None)\n  | ETrue  -> Some TBool\n  | EFalse -> Some TBool\n  | EIf e1 e2 e3 ->\n      (match typing g e1, typing g e2, typing g e3 with\n      | Some TBool, Some t2, Some t3 -> if t2 = t3 then Some t2 else None\n      | _         , _      , _       -> None)",
    "val progress : e:exp -> Lemma\n      (requires (Some? (typing empty e)))\n      (ensures (is_value e \\/ (Some? (step e))))\nlet rec progress e =\n  match e with\n  | EApp e1 e2 -> progress e1; progress e2\n  | EIf e1 e2 e3 -> progress e1; progress e2; progress e3\n  | _ -> ()",
    "val appears_free_in : x:int -> e:exp -> Tot bool\nlet rec appears_free_in x e =\n  match e with\n  | EVar y -> x = y\n  | EApp e1 e2 -> appears_free_in x e1 || appears_free_in x e2\n  | EAbs y _ e1 -> x <> y && appears_free_in x e1\n  | EIf e1 e2 e3 ->\n      appears_free_in x e1 || appears_free_in x e2 || appears_free_in x e3\n  | ETrue\n  | EFalse -> false",
    "val free_in_context : x:int -> e:exp -> g:env -> Lemma\n      (requires (Some? (typing g e)))\n      (ensures (appears_free_in x e ==> Some? (g x)))\nlet rec free_in_context x e g =\n  match e with\n  | EVar _\n  | ETrue\n  | EFalse -> ()\n  | EAbs y t e1 -> free_in_context x e1 (extend g y t)\n  | EApp e1 e2 -> free_in_context x e1 g; free_in_context x e2 g\n  | EIf e1 e2 e3 -> free_in_context x e1 g;\n                    free_in_context x e2 g; free_in_context x e3 g",
    "val typable_empty_closed : x:int -> e:exp -> Lemma\n      (requires (Some? (typing empty e)))\n      (ensures (not(appears_free_in x e)))\n      [SMTPat (appears_free_in x e)]\nlet typable_empty_closed x e = free_in_context x e empty",
    "logic type equal (g1:env) (g2:env) = forall (x:int). g1 x = g2 x",
    "logic type equalE (e:exp) (g1:env) (g2:env) =\n  forall (x:int). appears_free_in x e ==> g1 x = g2 x",
    "val context_invariance : e:exp -> g:env -> g':env -> Lemma\n  (requires (equalE e g g'))\n  (ensures (typing g e == typing g' e))\nlet rec context_invariance e g g' =\n  match e with\n  | EAbs x t e1 ->\n     context_invariance e1 (extend g x t) (extend g' x t)\n\n  | EApp e1 e2 ->\n     context_invariance e1 g g';\n     context_invariance e2 g g'\n\n  | EIf e1 e2 e3 ->\n     context_invariance e1 g g';\n     context_invariance e2 g g';\n     context_invariance e3 g g'\n\n  | _ -> ()",
    "val typing_extensional : g:env -> g':env -> e:exp -> Lemma\n  (requires (equal g g'))\n  (ensures (typing g e == typing g' e))\nlet typing_extensional g g' e = context_invariance e g g'",
    "val substitution_preserves_typing : x:int -> e:exp -> v:exp -> g:env -> Lemma\n  (requires (Some? (typing empty v) /\\\n             Some? (typing (extend g x (Some?.v (typing empty v))) e)))\n  (ensures (Some? (typing empty v) /\\\n            typing g (subst x v e) ==\n            typing (extend g x (Some?.v (typing empty v))) e))\nlet rec substitution_preserves_typing x e v g =\n  let Some t_x = typing empty v in\n  let gx = extend g x t_x in\n  match e with\n  | ETrue -> ()\n  | EFalse -> ()\n  | EVar y ->\n     if x=y\n     then context_invariance v empty g (* uses lemma typable_empty_closed *)\n     else context_invariance e gx g\n\n  | EApp e1 e2 ->\n     substitution_preserves_typing x e1 v g;\n     substitution_preserves_typing x e2 v g\n\n  | EIf e1 e2 e3 ->\n     substitution_preserves_typing x e1 v g;\n     substitution_preserves_typing x e2 v g;\n     substitution_preserves_typing x e3 v g\n\n  | EAbs y t_y e1 ->\n     let gxy = extend gx y t_y in\n     let gy = extend g y t_y in\n     if x=y\n     then typing_extensional gxy gy e1\n     else\n       (let gyx = extend gy x t_x in\n        typing_extensional gxy gyx e1;\n        substitution_preserves_typing x e1 v gy)",
    "val preservation : e:exp -> Lemma\n  (requires (Some? (typing empty e) /\\ Some? (step e) ))\n  (ensures (Some? (step e) /\\\n            typing empty (Some?.v (step e)) == typing empty e))\nlet rec preservation e =\n  match e with\n  | EApp e1 e2 ->\n     if is_value e1\n     then (if is_value e2\n           then let EAbs x _ ebody = e1 in\n                substitution_preserves_typing x ebody e2 empty\n           else preservation e2)\n     else preservation e1\n\n  | EIf e1 _ _ ->\n      if not (is_value e1) then preservation e1",
    "val typed_step : e:exp{Some? (typing empty e) /\\ not(is_value e)} ->\n                 Tot (e':exp{typing empty e' = typing empty e})",
    "let typed_step e = progress e; preservation e; Some?.v (step e)",
    "type tyP =\n  (* {{{ 2 unchanged cases omitted *)\n  | TBoolP  : tyP\n  | TArrowP : tin:tyP -> tout:tyP -> tyP\n  (* }}} *)\n  | TPairP : tyP -> tyP -> tyP\n\ntype expP =\n  (* {{{ 6 unchanged cases omitted *)\n  | EVarP   : v:var -> expP\n  | EAppP   : fn:expP -> arg:expP -> expP\n  | EAbsP   : v:var -> vty:tyP -> body:expP -> expP\n  | ETrueP  : expP\n  | EFalseP : expP\n  | EIfP    : test:expP -> btrue:expP -> bfalse:expP -> expP\n  (* }}} *)\n  | EPairP  : expP -> expP -> expP\n  | EFstP   : expP -> expP\n  | ESndP   : expP -> expP\n\nlet rec is_valueP e = (* Note the extra let rec! *)\n  match e with\n  (* {{{ 3 unchanged cases omitted *)\n  | EAbsP _ _ _\n  | ETrueP\n  | EFalseP     -> true\n  (* }}} *)\n  | EPairP e1 e2 -> is_valueP e1 && is_valueP e2\n  | _ -> false\n\nlet rec substP x e e' =\n  match e' with\n  (* {{{ 6 unchanged cases omitted *)\n  | EVarP x' -> if x = x' then e else e'\n  | EAbsP x' t e1 ->\n      EAbsP x' t (if x = x' then e1 else (substP x e e1))\n  | EAppP e1 e2 -> EAppP (substP x e e1) (substP x e e2)\n  | ETrueP -> ETrueP\n  | EFalseP -> EFalseP\n  | EIfP e1 e2 e3 -> EIfP (substP x e e1) (substP x e e2) (substP x e e3)\n  (* }}} *)\n  | EPairP e1 e2 -> EPairP (substP x e e1) (substP x e e2)\n  | EFstP e1 -> EFstP (substP x e e1)\n  | ESndP e1 -> ESndP (substP x e e1)\n\nlet rec stepP e =\n  match e with\n  (* {{{ 2 unchanged cases omitted *)\n  | EAppP e1 e2 ->\n      if is_valueP e1 then\n        if is_valueP e2 then\n          match e1 with\n          | EAbsP x t e' -> Some (substP x e2 e')\n          | _           -> None\n        else\n          match (stepP e2) with\n          | Some e2' -> Some (EAppP e1 e2')\n          | None     -> None\n      else\n        (match (stepP e1) with\n        | Some e1' -> Some (EAppP e1' e2)\n        | None     -> None)\n  | EIfP e1 e2 e3 ->\n      if is_valueP e1 then\n        match e1 with\n        | ETrueP   -> Some e2\n        | EFalseP  -> Some e3\n        | _       -> None\n      else\n        (match (stepP e1) with\n        | Some e1' -> Some (EIfP e1' e2 e3)\n        | None     -> None)\n  (* }}} *)\n  | EPairP e1 e2 ->\n      if is_valueP e1 then\n        if is_valueP e2 then None\n        else\n          (match (stepP e2) with\n          | Some e2' -> Some (EPairP e1 e2')\n          | None     -> None)\n      else\n        (match (stepP e1) with\n        | Some e1' -> Some (EPairP e1' e2)\n        | None     -> None)\n  | EFstP e1 ->\n      if is_valueP e1 then\n        (match e1 with\n        | EPairP v1 v2 -> Some v1\n        | _           -> None)\n      else\n        (match (stepP e1) with\n        | Some e1' -> Some (EFstP e1')\n        | None     -> None)\n  | ESndP e1 ->\n      if is_valueP e1 then\n        (match e1 with\n        | EPairP v1 v2 -> Some v2\n        | _           -> None)\n      else\n        (match (stepP e1) with\n        | Some e1' -> Some (ESndP e1')\n        | None     -> None)\n  | _ -> None",
    "type envP = int -> Tot (option tyP)\n\nval emptyP : envP\nlet emptyP = fun _ -> None",
    "val extendP : envP -> int -> tyP -> Tot envP\nlet extendP g x t = fun x' -> if x = x' then Some t else g x'\n\nval typingP : envP -> expP -> Tot (option tyP)\nlet rec typingP g e =\n  match e with\n  (* {{{ 6 unchanged cases omitted *)\n  | EVarP x -> g x\n  | EAbsP x t e1 ->\n      (match typingP (extendP g x t) e1 with\n      | Some t' -> Some (TArrowP t t')\n      | None    -> None)\n  | EAppP e1 e2 ->\n      (match typingP g e1, typingP g e2 with\n      | Some (TArrowP t11 t12), Some t2 -> if t11 = t2 then Some t12 else None\n      | _                    , _       -> None)\n  | ETrueP  -> Some TBoolP\n  | EFalseP -> Some TBoolP\n  | EIfP e1 e2 e3 ->\n      (match typingP g e1, typingP g e2, typingP g e3 with\n      | Some TBoolP, Some t2, Some t3 -> if t2 = t3 then Some t2 else None\n      | _         , _      , _       -> None)\n\n  (* }}} *)\n  | EPairP e1 e2 ->\n      (match typingP g e1, typingP g e2 with\n      | Some t1, Some t2 -> Some (TPairP t1 t2)\n      | _      , _       -> None)\n  | EFstP e1 ->\n      (match typingP g e1 with\n      | Some (TPairP t1 t2) -> Some t1\n      | _                  -> None)\n  | ESndP e1 ->\n      (match typingP g e1 with\n      | Some (TPairP t1 t2) -> Some t2\n      | _                  -> None)\n\nval appears_free_inP : x:int -> e:expP -> Tot bool\nlet rec appears_free_inP x e =\n  match e with\n  (* {{{ 6 unchanged cases omitted *)\n  | EVarP y -> x = y\n  | EAppP e1 e2 -> appears_free_inP x e1 || appears_free_inP x e2\n  | EAbsP y _ e1 -> x <> y && appears_free_inP x e1\n  | EIfP e1 e2 e3 ->\n      appears_free_inP x e1 || appears_free_inP x e2 || appears_free_inP x e3\n  | ETrueP\n  | EFalseP -> false\n  (* }}} *)\n  | EPairP e1 e2 -> appears_free_inP x e1 || appears_free_inP x e2\n  | EFstP e1 -> appears_free_inP x e1\n  | ESndP e1 -> appears_free_inP x e1",
    "val free_in_contextP : x:int -> e:expP -> g:envP -> Lemma\n      (requires (Some? (typingP g e)))\n      (ensures (appears_free_inP x e ==> Some? (g x)))\nlet rec free_in_contextP x e g =\n  match e with\n  (* {{{ 6 unchanged cases omitted *)\n  | EVarP _\n  | ETrueP\n  | EFalseP -> ()\n  | EAbsP y t e1 -> free_in_contextP x e1 (extendP g y t)\n  | EAppP e1 e2 -> free_in_contextP x e1 g; free_in_contextP x e2 g\n  | EIfP e1 e2 e3 -> free_in_contextP x e1 g;\n                    free_in_contextP x e2 g; free_in_contextP x e3 g\n  (* }}} *)\n  | EPairP e1 e2 -> free_in_contextP x e1 g; free_in_contextP x e2 g\n  | EFstP e1\n  | ESndP e1 -> free_in_contextP x e1 g\n\nlogic type equalEP (e:expP) (g1:envP) (g2:envP) =\n  forall (x:int). appears_free_inP x e ==> g1 x = g2 x\n\nval context_invarianceP : e:expP -> g:envP -> g':envP -> Lemma\n  (requires (equalEP e g g'))\n  (ensures (typingP g e == typingP g' e))\nlet rec context_invarianceP e g g' =\n  match e with\n  (* {{{ 3 unchanged cases omitted *)\n  | EAbsP x t e1 ->\n     context_invarianceP e1 (extendP g x t) (extendP g' x t)\n\n  | EAppP e1 e2 ->\n     context_invarianceP e1 g g';\n     context_invarianceP e2 g g'\n\n  | EIfP e1 e2 e3 ->\n     context_invarianceP e1 g g';\n     context_invarianceP e2 g g';\n     context_invarianceP e3 g g'\n  (* }}} *)\n\n  | EPairP e1 e2 ->\n     context_invarianceP e1 g g';\n     context_invarianceP e2 g g'\n\n  | EFstP e1\n  | ESndP e1 -> context_invarianceP e1 g g'\n\n  | _ -> ()\n\n(* {{{ similar definitions skipped *)\nlogic type equalP (g1:envP) (g2:envP) = forall (x:int). g1 x = g2 x\n\nval typing_extensionalP : g:envP -> g':envP -> e:expP -> Lemma\n  (requires (equalP g g'))\n  (ensures (typingP g e == typingP g' e))\nlet typing_extensionalP g g' e = context_invarianceP e g g'\n\nval typable_empty_closedP : x:int -> e:expP -> Lemma\n      (requires (Some? (typingP emptyP e)))\n      (ensures (not(appears_free_inP x e)))\n      [SMTPat (appears_free_inP x e)]\nlet typable_empty_closedP x e = free_in_contextP x e emptyP\n(* }}} *)\n\nval substitution_preserves_typingP : x:int -> e:expP -> v:expP -> g:envP -> Lemma\n  (requires (Some? (typingP emptyP v) /\\\n             Some? (typingP (extendP g x (Some?.v (typingP emptyP v))) e)))\n  (ensures (Some? (typingP emptyP v) /\\\n            typingP g (substP x v e) ==\n            typingP (extendP g x (Some?.v (typingP emptyP v))) e))\nlet rec substitution_preserves_typingP x e v g =\n  (* {{{ unchanged preamble skipped *)\n  let Some t_x = typingP emptyP v in\n  let gx = extendP g x t_x in\n  match e with\n  | ETrueP -> ()\n  | EFalseP -> ()\n  | EVarP y ->\n     if x=y\n     then context_invarianceP v emptyP g (* uses lemma typable_empty_closed *)\n     else context_invarianceP e gx g\n\n  | EAppP e1 e2 ->\n     substitution_preserves_typingP x e1 v g;\n     substitution_preserves_typingP x e2 v g\n\n  | EIfP e1 e2 e3 ->\n     substitution_preserves_typingP x e1 v g;\n     substitution_preserves_typingP x e2 v g;\n     substitution_preserves_typingP x e3 v g\n\n  | EAbsP y t_y e1 ->\n     let gxy = extendP gx y t_y in\n     let gy = extendP g y t_y in\n     if x=y\n     then typing_extensionalP gxy gy e1\n     else\n       (let gyx = extendP gy x t_x in\n        typing_extensionalP gxy gyx e1;\n        substitution_preserves_typingP x e1 v gy)\n  (* }}} *)\n\n  | EPairP e1 e2 ->\n     (substitution_preserves_typingP x e1 v g;\n      substitution_preserves_typingP x e2 v g)\n\n  | EFstP e1\n  | ESndP e1 ->\n      substitution_preserves_typingP x e1 v g\n\n  | _ -> ()",
    "val preservationP : e:expP{Some? (typingP emptyP e) /\\ Some? (stepP e)} ->\n      Tot (u:unit{typingP emptyP (Some?.v (stepP e)) == typingP emptyP e})\nlet rec preservationP e =\n  match e with\n  (* {{{ two unchanged cases *)\n  | EAppP e1 e2 ->\n     if is_valueP e1\n     then (if is_valueP e2\n           then let EAbsP x _ ebody = e1 in\n                substitution_preserves_typingP x ebody e2 emptyP\n           else preservationP e2)\n     else preservationP e1\n\n  | EIfP e1 _ _ ->\n      if not (is_valueP e1) then preservationP e1\n  (* }}} *)\n\n  | EPairP e1 e2 ->\n      (match is_valueP e1, is_valueP e2 with\n      | false, _     -> preservationP e1\n      | true , false -> preservationP e2)\n\n  | EFstP e1\n  | ESndP e1 ->\n      if not (is_valueP e1) then preservationP e1",
    "val eval : e:exp{Some? (typing empty e)} ->\n           Dv (v:exp{is_value v && typing empty v = typing empty e})",
    "let rec eval e =\n  if is_value e then e\n  else eval (typed_step e)",
    "val eval' : e:exp{Some? (typing empty e)} ->\n  Dv (v:exp{is_value v && typing empty v = typing empty e})\nlet rec eval' e = match step e with\n  | None -> progress e; e\n  | Some e' -> preservation e; eval' e'",
    "val eval'' : e:exp{Some? (typing empty e)} ->\n            Dv (v:exp{is_value v && typing empty v = typing empty e})\nlet rec eval'' e =\n  let Some t = typing empty e in\n  match e with\n  | EApp e1 e2 ->\n     (let EAbs x _ e' = eval' e1 in\n      let v = eval' e2 in\n      substitution_preserves_typing x e' v empty;\n      eval'' (subst x v e'))\n  | EAbs _ _ _\n  | ETrue\n  | EFalse     -> e\n  | EIf e1 e2 e3 ->\n     (match eval'' e1 with\n      | ETrue  -> eval'' e2\n      | EFalse -> eval'' e3)"
];

function onMessage(message) {
    console.log("message:", message);
}

var ide = new FStar.Driver.IDE(fname, fblocks.join("\n\n"), args, onMessage);

FStar.SMTDriver.CLI.initAsync(function() {
    setTimeout(function () {
        fblocks.forEach(function(block) {
            console.log(">>>", block.replace(/[\r\n]+$/, ""));
            console.log(ide.evalSync(FStar.IDE.Utils.mkPush("0", "full", block, 1, 0)));
        });
    }, 0);
});
